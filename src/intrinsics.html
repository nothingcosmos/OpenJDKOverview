

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>intrinsics &mdash; OpenJDK Internals 1.0 documentation</title>
    
    <link rel="stylesheet" href="../static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../static/jquery.js"></script>
    <script type="text/javascript" src="../static/underscore.js"></script>
    <script type="text/javascript" src="../static/doctools.js"></script>
    <script type="text/javascript" src="../_static/theme_extras.js"></script>
    <link rel="top" title="OpenJDK Internals 1.0 documentation" href="../index.html" />
    <link rel="next" title="Shark" href="shark.html" />
    <link rel="prev" title="2011 1014 java one" href="javaone.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="../index.html">
          <span>OpenJDK Internals 1.0 documentation</span></a></h1>
        <h2 class="heading"><span>intrinsics</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="javaone.html">2011 1014 java one</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="shark.html">Shark</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="intrinsics">
<h1>intrinsics<a class="headerlink" href="#intrinsics" title="Permalink to this headline">¶</a></h1>
<p>JVMはcpu依存の機能を提供するため、組込み関数(以降intrinsics)を定義している。</p>
<p>JVMはC++で開発されているため、JavaからJNIのnativeを使用してintrinsicsを呼び出す。</p>
<p>例をあげると、compare-and-swap.
class fileからはnative関数として呼び出され、JVM側でnativeな関数を定義している。</p>
<p>JVMはintrinsicsをcpu非依存に提供する。intrinsicsを提供する処理はおもに2種類ある。</p>
<ol class="arabic simple">
<li>cpu依存の特殊な処理</li>
<li>cpu依存で高速化している処理</li>
</ol>
<p>cpu依存は2種類に分けられて、</p>
<ol class="arabic simple">
<li>cpuのアーキテクチャ(arch)の違い。x86の場合はcmpxchg命令、sparcの場合はcasx命令など。</li>
<li>同じarchのInstruction Set Architectureの違い。cpuによって実装されていない命令は、他命令群で代替する。</li>
</ol>
<p>cpu依存で高速化している処理は、mmxやsseがある場合、それ向けの高速な処理を使用する。</p>
<p>例をあげると、sse4を使用して128bitずつのarray copyやcompareなど。</p>
<p>JVMはOSとArchごとにbuildされ提供されているが、cpuのISAごとには提供されない。</p>
<p>そのため、ISA依存の処理はJVMの起動時に生成する。のでは？</p>
<div class="section" id="id1">
<h2>ここまで一般的な話<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>compare-and-swapを例に処理を追っていたのですが、
x86のcmpxchgのISAはi486であり、JVMの前提ISAはi586なので、
インタプリタからもJITコンパイラからも自由に呼び出せるようです。</p>
<p>昔のi386向けのJVMだったら、cmpxchgがISA依存で処理が分かれていたかもしれませんね。。</p>
<p>#ParaConBase では、JVM起動時にこれらのCPU依存処理を生成して、
インタプリタやJITコンパイルしたコードから飛び込むみたいなことを言いましたが、
Dart VMの話とごっちゃになっていたようです。。</p>
</div>
<div class="section" id="id2">
<h2>起点<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>compareAndSwapIntと、cmpxchgを例に追ってみます。</p>
<p>penjdk7u/jdk/src/share/classes/sun/misc/Unsafe.java</p>
<div class="highlight-python"><pre>public final native boolean compareAndSwapInt(Object o, long offset,
                                              int expected,
                                              int x);</pre>
</div>
</div>
<div class="section" id="compareandswapint">
<h2>compareAndSwapIntを探す。<a class="headerlink" href="#compareandswapint" title="Permalink to this headline">¶</a></h2>
<p>openjdk7u/hotspot/src/share/vm</p>
<div class="highlight-python"><pre>//unsafeのnativeの実装はすべてここ。
prims/unsafe.cpp:    {CC"compareAndSwapInt",  CC"("OBJ"J""I""I"")Z",      FN_PTR(Unsafe_CompareAndSwapInt)},
prims/unsafe.cpp:    {CC"compareAndSwapInt",  CC"("OBJ"J""I""I"")Z",      FN_PTR(Unsafe_CompareAndSwapInt)},
  runtime/atomic.cpp:Atomic::cmpxchg(x, addr, e)
    Atomic::cmpxchg(jint, uintptr_t, jint) &lt;-- これの定義がどこにあるのか不明だった。

//JVMのintrinsicsを定義してる(実装はマクロで展開する)
classfile/vmSymbols.hpp:  do_intrinsic(_compareAndSwapInt,        sun_misc_Unsafe,        compareAndSwapInt_name, compareAndSwapInt_signature, F_RN) \
classfile/vmSymbols.hpp:   do_name(     compareAndSwapInt_name,                          "compareAndSwapInt")                                   \
classfile/vmSymbols.hpp:   do_signature(compareAndSwapInt_signature,                     "(Ljava/lang/Object;JII)Z")                            \

//c1はclient JITコンパイラ用のディレクトリ
c1/c1_GraphBuilder.cpp:    case vmIntrinsics::_compareAndSwapInt:
c1/c1_LIRGenerator.cpp:  case vmIntrinsics::_compareAndSwapInt:

//optoはServer JITコンパイラ用のディレクトリ
opto/library_call.cpp:  case vmIntrinsics::_compareAndSwapInt:        return inline_unsafe_load_store(T_INT,    LS_cmpxchg);
opto/library_call.cpp://   public final native boolean compareAndSwapInt(   Object o, long offset, int    expected, int    x);

//sharkはJVMのJITコンパイラにLLVMを使用するwrapper
shark/sharkIntrinsics.cpp:  case vmIntrinsics::_compareAndSwapInt:
shark/sharkIntrinsics.cpp:  case vmIntrinsics::_compareAndSwapInt:
shark/sharkIntrinsics.cpp:    do_Unsafe_compareAndSwapInt();
shark/sharkIntrinsics.cpp:void SharkIntrinsics::do_Unsafe_compareAndSwapInt() {
shark/sharkIntrinsics.hpp:  void do_Unsafe_compareAndSwapInt();</pre>
</div>
</div>
<div class="section" id="cmpxchg">
<h2>cmpxchg<a class="headerlink" href="#cmpxchg" title="Permalink to this headline">¶</a></h2>
<p>cmpxchgは、linuxの場合、以下のファイルで定義されています。(ia32版)</p>
<p>この段階で、cmpxchgがISAごとに定義がわかれていないことに気づく。。</p>
<p>openjdk7u/hotspot/src/os_cpu/linux_x86/vm/atomic_linux_x86.inline.hpp</p>
<div class="highlight-python"><pre>inline jint     Atomic::cmpxchg    (jint     exchange_value, volatile jint*     dest, jint     compare_value) {
  int mp = os::is_MP();
  __asm__ volatile (LOCK_IF_MP(%4) "cmpxchgl %1,(%3)"
                    : "=a" (exchange_value)
                    : "r" (exchange_value), "a" (compare_value), "r" (dest), "r" (mp)
                    : "cc", "memory");
  return exchange_value;
}</pre>
</div>
<p>JVMはbytecodeをインタプリタ実行するはずです。</p>
<p>おそらくインタプリタ実行の際にcompareAndSwapIntの呼び出しがあれば、
最終的に上記で定義されているAtomic::cmpxchgを呼び出すはずです。</p>
</div>
<div class="section" id="id3">
<h2>じゃぁ他の定義はなんだったのか。。<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>x86の場合、最終的にcmpxchg命令が呼ばれますが、その経路は4種類あります。</p>
<ol class="arabic simple">
<li>インタプリタ実行時に呼び出す処理</li>
<li>client JITコンパイラでコンパイルされたコードに埋め込む処理</li>
<li>server JITコンパイラでコンパイルされたコードに埋め込む処理</li>
<li>shark JITコンパイラでコンパイルされたコードに埋め込む処理</li>
</ol>
</div>
<div class="section" id="vmsymbols">
<h2>vmSymbols<a class="headerlink" href="#vmsymbols" title="Permalink to this headline">¶</a></h2>
<p>classfile/vmSymbols.hppでは、JVMの組込み関数が定義されており、
bytecodeをJITコンパイルする際に、intrinsics呼び出しとして扱います。</p>
<p>classfile/vmSymbols.hpp</p>
<div class="highlight-python"><pre>do_intrinsic(_compareAndSwapInt,        sun_misc_Unsafe,        compareAndSwapInt_name, compareAndSwapInt_signature, F_RN) \
do_name(     compareAndSwapInt_name,                          "compareAndSwapInt")                                   \
do_signature(compareAndSwapInt_signature,                     "(Ljava/lang/Object;JII)Z")                            \</pre>
</div>
<p>上記の文字列にマッチすると、JVM内ではvmIntrinsics::_compareAndSwapIntの組込み関数呼び出しと扱います。</p>
<p>おそらく、invoke-&gt;intrinsc_id() == vmIntrinsics::_compareAndSwapInt</p>
</div>
<div class="section" id="client-jit">
<h2>client JITコンパイラ<a class="headerlink" href="#client-jit" title="Permalink to this headline">¶</a></h2>
<p>C1はclient JITコンパイラ</p>
<div class="highlight-python"><pre>c1/c1_GraphBuilder.cpp:
  case vmIntrinsics::_compareAndSwapInt:
  case vmIntrinsics::_compareAndSwapObject:
    append_unsafe_CAS(callee);
      Intrinsic* result = new Intrinsic(result_type, callee-&gt;intrinsic_id(), args, false, state_before, preserves_state);
    return true;

c1/c1_LIRGenerator.cpp:
  case vmIntrinsics::_compareAndSwapInt:
    do_CompareAndSwap(x, intType);
    break;

src/cpu/x86/vm/c1_LIRGenerator_x86.cpp
  void LIRGenerator::do_CompareAndSwap(Intrinsic* x, ValueType* type) {
  ...
    } else if (type == intType) {
      cmp.load_item_force(FrameMap::rax_opr);
      val.load_item();
  ...
    else if (type == intType)
      __ cas_int(addr, cmp.result(), val.result(), ill, ill);
  ...

src/share/vm/c1/c1_LIR.cpp
  void LIR_List::cas_int(LIR_Opr addr, LIR_Opr cmp_value, LIR_Opr new_value,
                         LIR_Opr t1, LIR_Opr t2, LIR_Opr result /*=LIR_OprFact::illegalOpr*/) {
    append(new LIR_OpCompareAndSwap(lir_cas_int, addr, cmp_value, new_value, t1, t2, result));
  }

LIR_OpCompareAndSwapは、c1コンパイラのLIRノードなので、別途emit_code()が走ってアセンブラを生成する。
src/share/vm/c1/c1_LIR.cpp
  void LIR_OpCompareAndSwap::emit_code(LIR_Assembler* masm) {
    masm-&gt;emit_compare_and_swap(this);
  }


src/cpu/x86/vm/c1_LIRAssembler_x86.cpp
  void LIR_Assembler::emit_compare_and_swap(LIR_OpCompareAndSwap* op) {
    ...
    assert(op-&gt;code() == lir_cas_int, "lir_cas_int expected");
    if (os::is_MP()) {
      __ lock();
    }
    __ cmpxchgl(newval, Address(addr, 0));

やっとcmpxchg命令がemitされたよ。。</pre>
</div>
<p>デバッガで追ったわけではaりませんが、こんな感じだと思われます。</p>
<p>サンプルコードを生成してアセンブリ命令を出力してみます。</p>
<p>CAS.java</p>
<div class="highlight-python"><pre>import java.util.concurrent.atomic.*;
public class CAS{
  public static void main (String[] args) {
    AtomicInteger ai = new AtomicInteger();
    for (int i=0; i&lt;1000000000; i++) {
      kernel(ai);
    }
    System.out.println("ret = " + ai.get() + "\n");
  }
  public static int kernel(AtomicInteger ai) {
    return ai.incrementAndGet();
  }
}

こんな感じで、LIRにcas_intに置き替えられて、それがlock cmpxchgになっている。

12 label [label:0x9fb889ac]
14 move [edx|I] [eax|I]
0xb46a739f: mov    %edx,%eax
16 leal [Base:[ecx|L] Disp: 8|I] [edi|I]
0xb46a73a1: lea    0x8(%ecx),%edi
18 cas_int [edi|I] [eax|I] [esi|I]
0xb46a73a4: lock cmpxchg %esi,(%edi)
20 cmove [EQ] [int:1|I] [int:0|I] [eax|I]
0xb46a73a8: mov    $0x1,%eax
0xb46a73ad: je     0xb46a73b8
0xb46a73b3: mov    $0x0,%eax
24 return [eax|I]
0xb46a73b8: add    $0x28,%esp
0xb46a73bb: pop    %ebp
0xb46a73bc: test   %eax,0xb770b100
0xb46a73c2: ret</pre>
</div>
<p>結論として、client JITコンパイルしたコードに、cmpxchgは埋め込まれる。。</p>
</div>
<div class="section" id="server-jit">
<h2>server JITコンパイラ<a class="headerlink" href="#server-jit" title="Permalink to this headline">¶</a></h2>
<p>ガッツが足りないので、細かいところは省略です。</p>
<p>optoはServer JITコンパイラ</p>
<div class="highlight-python"><pre>opto/library_call.cpp:  case vmIntrinsics::_compareAndSwapInt:        return inline_unsafe_load_store(T_INT,    LS_cmpxchg);
opto/library_call.cpp://   public final native boolean compareAndSwapInt(   Object o, long offset, int    expected, int    x);

        # CAS::kernel @ bci:1  L[0]=_
        # OopMap{ecx=Oop ebx=Derived_oop_ecx ebp=Oop off=60}
042     MOV    EAX,[ECX + #8]   # int ! Field  Volatilejava/util/concurrent/atomic/AtomicInteger.value
045     MEMBAR-acquire ! (empty encoding)
045     MEMBAR-release ! (empty encoding)
045
045     MOV    ECX,EAX
047     INC    ECX
048     CMPXCHG [EBX],ECX       # If EAX==[EBX] Then store ECX into [EBX]
        MOV    EDI,0
        JNE,s  fail
        MOV    EDI,1
fail:
058
058     MEMBAR-acquire ! (empty encoding)
058     TEST   EDI,EDI
05a     Je,s  B6  P=0.000000 C=46393.000000</pre>
</div>
<p>serverコンパイラの場合、コンパイラ内部の取扱いはもっと複雑なのですが、</p>
<p>出力は似たようにJITコンパイルしたコードに、cmpxchgを埋め込みます。</p>
</div>
</div>
<div class="section" id="shark-jit">
<h1>shark JITコンパイラ<a class="headerlink" href="#shark-jit" title="Permalink to this headline">¶</a></h1>
<p>sharkは、JVMのJITコンパイルにLLVMを使用するためのwrapperです。</p>
<p>JITコンパイルする際に、bytecodeからbitcode(LLVM IRってやつ)に変換して、</p>
<p>LLVM IRをLLVMにJITコンパイルさせて、アセンブラを出力します。</p>
<p>shark/sharkIntrinsics.cpp</p>
<div class="highlight-python"><pre>void SharkIntrinsics::do_Unsafe_compareAndSwapInt() {
  // Pop the arguments
  Value *x      = state()-&gt;pop()-&gt;jint_value();
  Value *e      = state()-&gt;pop()-&gt;jint_value();
  SharkValue *empty = state()-&gt;pop();
  assert(empty == NULL, "should be");
  Value *offset = state()-&gt;pop()-&gt;jlong_value();
  Value *object = state()-&gt;pop()-&gt;jobject_value();
  Value *unsafe = state()-&gt;pop()-&gt;jobject_value();

  // Convert the offset
  offset = builder()-&gt;CreateCall(
    builder()-&gt;unsafe_field_offset_to_byte_offset(),
    offset);

  // Locate the field
  Value *addr = builder()-&gt;CreateIntToPtr(
    builder()-&gt;CreateAdd(
      builder()-&gt;CreatePtrToInt(object, SharkType::intptr_type()),
      builder()-&gt;CreateIntCast(offset, SharkType::intptr_type(), true)),
    PointerType::getUnqual(SharkType::jint_type()),
    "addr");

  // Perform the operation
  Value *result = builder()-&gt;CreateCmpxchgInt(x, addr, e); &lt;--  これは！！！

  // Push the result
  state()-&gt;push(
    SharkValue::create_jint(
      builder()-&gt;CreateIntCast(
        builder()-&gt;CreateICmpEQ(result, e), SharkType::jint_type(), true),
      false));
}</pre>
</div>
<p>上記のようにLLVM IRをbuilderを使って作成するのですが、きもは、CreateCmpxchgInt()のところ。</p>
<p>LLVMの組込み関数 llvm.atomic.cmp.swap.i32.p0i32 を内部で生成しています。</p>
<p>LLVMがJITコンパイルする際に、対象アーキテクチャのcas命令を生成してくれるはずです。</p>
</div>
<div class="section" id="macroassembler">
<h1>MacroAssembler<a class="headerlink" href="#macroassembler" title="Permalink to this headline">¶</a></h1>
<p>ここからは上記とあまり関係がないメモ書きです。</p>
<div class="section" id="c2intrinsics">
<h2>C2のintrinsics<a class="headerlink" href="#c2intrinsics" title="Permalink to this headline">¶</a></h2>
<p>JVMのintrinsicsは、 classfile/vmSymbolsに定義されている。</p>
<p>c2コンパイラの場合、以下で各々のシンボルに変換される。</p>
<p>opto/doCall optoコンパイラ内部のシンボルに変換</p>
<p>opto/library_call.cpp  Macro Assembler向けのシンボルに変換</p>
<p>cpu/vm/x86/xxx  Macro Assemblerの定義がある。</p>
</div>
<div class="section" id="arraycopy">
<h2>arrayCopy<a class="headerlink" href="#arraycopy" title="Permalink to this headline">¶</a></h2>
<p>jvmのarrayCopyは、x86archの下に、複数の型ごとにarrayCopyのgeneratorを用意していて、</p>
<p>JITコンパイル時にgeneratorを切り替えている。</p>
<p>generatorの下では、loopalignされた状態でcopyするっぽい。</p>
<p>mmxとxmmの切り替えは実行時に行う見たいだけど、SSEやAVX向けはなし。</p>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="javaone.html">2011 1014 java one</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="shark.html">Shark</a>&#160;&#160;»
        </p>

      </div>


    <div class="footer">
        &copy; Copyright 2011, nothingcosmos.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>

<script type="text/javascript">

var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-15223787-2']);
_gaq.push(['_trackPageview']);

(function() {
 var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
 ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
 var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
 })();

</script>


  </body>
</html>