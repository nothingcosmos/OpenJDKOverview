diff /home/elise/language/openjdk6/hotspot/src/share/vm/c1/c1_Canonicalizer.cpp /home/elise/language/openjdk/hotspot/src/share/vm/c1/c1_Canonicalizer.cpp
212c212
<                                        x->state_before(), x->is_loaded(), x->is_initialized()));
---
>                                    x->state_before(), x->needs_patching()));
901c901
< 
---
>   virtual void do_RuntimeCall    (RuntimeCall*     x);
diff /home/elise/language/openjdk6/hotspot/src/share/vm/c1/c1_CodeStubs.hpp /home/elise/language/openjdk/hotspot/src/share/vm/c1/c1_CodeStubs.hpp
479c479
< class ArrayStoreExceptionStub: public CodeStub {
---
> class ArrayStoreExceptionStub: public SimpleExceptionStub {
484,490c484
<   ArrayStoreExceptionStub(CodeEmitInfo* info);
<   virtual void emit_code(LIR_Assembler* emit);
<   virtual CodeEmitInfo* info() const             { return _info; }
<   virtual bool is_exception_throw_stub() const   { return true; }
<   virtual void visit(LIR_OpVisitState* visitor) {
<     visitor->do_slow_case(_info);
<   }
---
>   ArrayStoreExceptionStub(LIR_Opr obj, CodeEmitInfo* info): SimpleExceptionStub(Runtime1::throw_array_store_exception_id, obj, info) {}
527a522
>   bool _do_load;
534c529
<   // pre_val (a temporary register) must be a register;
---
>   // Version that _does_ generate a load of the previous value from addr.
535a531
>   // pre_val (a temporary register) must be a register;
537c533,534
<     _addr(addr), _pre_val(pre_val), _patch_code(patch_code), _info(info)
---
>     _addr(addr), _pre_val(pre_val), _do_load(true),
>     _patch_code(patch_code), _info(info)
542a540,548
>   // Version that _does not_ generate load of the previous value; the
>   // previous value is assumed to have already been loaded into pre_val.
>   G1PreBarrierStub(LIR_Opr pre_val) :
>     _addr(LIR_OprFact::illegalOpr), _pre_val(pre_val), _do_load(false),
>     _patch_code(lir_patch_none), _info(NULL)
>   {
>     assert(_pre_val->is_register(), "should be a register");
>   }
> 
546a553
>   bool do_load() const { return _do_load; }
550,554c557,567
<     // don't pass in the code emit info since it's processed in the fast
<     // path
<     if (_info != NULL)
<       visitor->do_slow_case(_info);
<     else
---
>     if (_do_load) {
>       // don't pass in the code emit info since it's processed in the fast
>       // path
>       if (_info != NULL)
>         visitor->do_slow_case(_info);
>       else
>         visitor->do_slow_case();
> 
>       visitor->do_input(_addr);
>       visitor->do_temp(_pre_val);
>     } else {
556,557c569,570
<     visitor->do_input(_addr);
<     visitor->do_temp(_pre_val);
---
>       visitor->do_input(_pre_val);
>     }
563a577,641
> // This G1 barrier code stub is used in Unsafe.getObject.
> // It generates a sequence of guards around the SATB
> // barrier code that are used to detect when we have
> // the referent field of a Reference object.
> // The first check is assumed to have been generated
> // in the code generated for Unsafe.getObject().
> 
> class G1UnsafeGetObjSATBBarrierStub: public CodeStub {
>  private:
>   LIR_Opr _val;
>   LIR_Opr _src;
> 
>   LIR_Opr _tmp;
>   LIR_Opr _thread;
> 
>   bool _gen_src_check;
> 
>  public:
>   // A G1 barrier that is guarded by generated guards that determine whether
>   // val (which is the result of Unsafe.getObject() should be recorded in an
>   // SATB log buffer. We could be reading the referent field of a Reference object
>   // using Unsafe.getObject() and we need to record the referent.
>   //
>   // * val is the operand returned by the unsafe.getObject routine.
>   // * src is the base object
>   // * tmp is a temp used to load the klass of src, and then reference type
>   // * thread is the thread object.
> 
>   G1UnsafeGetObjSATBBarrierStub(LIR_Opr val, LIR_Opr src,
>                                 LIR_Opr tmp, LIR_Opr thread,
>                                 bool gen_src_check) :
>     _val(val), _src(src),
>     _tmp(tmp), _thread(thread),
>     _gen_src_check(gen_src_check)
>   {
>     assert(_val->is_register(), "should have already been loaded");
>     assert(_src->is_register(), "should have already been loaded");
> 
>     assert(_tmp->is_register(), "should be a temporary register");
>   }
> 
>   LIR_Opr val() const { return _val; }
>   LIR_Opr src() const { return _src; }
> 
>   LIR_Opr tmp() const { return _tmp; }
>   LIR_Opr thread() const { return _thread; }
> 
>   bool gen_src_check() const { return _gen_src_check; }
> 
>   virtual void emit_code(LIR_Assembler* e);
> 
>   virtual void visit(LIR_OpVisitState* visitor) {
>     visitor->do_slow_case();
>     visitor->do_input(_val);
>     visitor->do_input(_src);
>     visitor->do_input(_thread);
> 
>     visitor->do_temp(_tmp);
>   }
> 
> #ifndef PRODUCT
>   virtual void print_name(outputStream* out) const { out->print("G1UnsafeGetObjSATBBarrierStub"); }
> #endif // PRODUCT
> };
> 
diff /home/elise/language/openjdk6/hotspot/src/share/vm/c1/c1_Compilation.cpp /home/elise/language/openjdk/hotspot/src/share/vm/c1/c1_Compilation.cpp
494c494
<   } else if (is_profiling() && _would_profile) {
---
>   } else if (is_profiling()) {
496,497c496,498
<     assert(md != NULL, "Sanity");
<     md->set_would_profile(_would_profile);
---
>     if (md != NULL) {
>       md->set_would_profile(_would_profile);
>     }
diff /home/elise/language/openjdk6/hotspot/src/share/vm/c1/c1_Defs.hpp /home/elise/language/openjdk/hotspot/src/share/vm/c1/c1_Defs.hpp
37a38,43
> #ifdef TARGET_ARCH_arm
> # include "register_arm.hpp"
> #endif
> #ifdef TARGET_ARCH_ppc
> # include "register_ppc.hpp"
> #endif
52a59,64
> #ifdef TARGET_ARCH_arm
> # include "c1_Defs_arm.hpp"
> #endif
> #ifdef TARGET_ARCH_ppc
> # include "c1_Defs_ppc.hpp"
> #endif
diff /home/elise/language/openjdk6/hotspot/src/share/vm/c1/c1_FpuStackSim.hpp /home/elise/language/openjdk/hotspot/src/share/vm/c1/c1_FpuStackSim.hpp
40a41,46
> #ifdef TARGET_ARCH_arm
> # include "c1_FpuStackSim_arm.hpp"
> #endif
> #ifdef TARGET_ARCH_ppc
> # include "c1_FpuStackSim_ppc.hpp"
> #endif
diff /home/elise/language/openjdk6/hotspot/src/share/vm/c1/c1_FrameMap.cpp /home/elise/language/openjdk/hotspot/src/share/vm/c1/c1_FrameMap.cpp
37a38,43
> #ifdef TARGET_ARCH_arm
> # include "vmreg_arm.inline.hpp"
> #endif
> #ifdef TARGET_ARCH_ppc
> # include "vmreg_ppc.inline.hpp"
> #endif
diff /home/elise/language/openjdk6/hotspot/src/share/vm/c1/c1_FrameMap.hpp /home/elise/language/openjdk/hotspot/src/share/vm/c1/c1_FrameMap.hpp
90a91,96
> #ifdef TARGET_ARCH_arm
> # include "c1_FrameMap_arm.hpp"
> #endif
> #ifdef TARGET_ARCH_ppc
> # include "c1_FrameMap_ppc.hpp"
> #endif
diff /home/elise/language/openjdk6/hotspot/src/share/vm/c1/c1_GraphBuilder.cpp /home/elise/language/openjdk/hotspot/src/share/vm/c1/c1_GraphBuilder.cpp
32a33
> #include "compiler/compileBroker.hpp"
1398a1400,1406
>     if (compilation()->env()->dtrace_method_probes()) {
>       // Report exit from inline methods
>       Values* args = new Values(1);
>       args->push(append(new Constant(new ObjectConstant(method()))));
>       append(new RuntimeCall(voidType, "dtrace_method_exit", CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit), args));
>     }
> 
1452,1454c1460,1462
<   const bool is_loaded = holder->is_loaded() &&
<                          field->will_link(method()->holder(), code);
<   const bool is_initialized = is_loaded && holder->is_initialized();
---
>   const bool needs_patching = !holder->is_loaded() ||
>                               !field->will_link(method()->holder(), code) ||
>                               PatchALot;
1457c1465
<   if (!is_initialized || PatchALot) {
---
>   if (!holder->is_initialized() || needs_patching) {
1465,1468d1472
<     // commoning of class constants should only occur if the class is
<     // fully initialized and resolved in this constant pool.  The will_link test
<     // above essentially checks if this class is resolved in this constant pool
<     // so, the is_initialized flag should be suffiect.
1471c1475
<       obj = new Constant(new ClassConstant(holder), state_before);
---
>       obj = new Constant(new InstanceConstant(holder->java_mirror()), state_before);
1473c1477
<       obj = new Constant(new ClassConstant(holder));
---
>       obj = new Constant(new InstanceConstant(holder->java_mirror()));
1478c1482
<   const int offset = is_loaded ? field->offset() : -1;
---
>   const int offset = !needs_patching ? field->offset() : -1;
1505c1509
<                                         state_before, is_loaded, is_initialized)));
---
>                                         state_before, needs_patching)));
1514c1518
<         append(new StoreField(append(obj), offset, field, val, true, state_before, is_loaded, is_initialized));
---
>         append(new StoreField(append(obj), offset, field, val, true, state_before, needs_patching));
1522,1523c1526,1527
<         LoadField* load = new LoadField(apop(), offset, field, false, state_before, is_loaded, true);
<         Value replacement = is_loaded ? _memory->load(load) : load;
---
>         LoadField* load = new LoadField(apop(), offset, field, false, state_before, needs_patching);
>         Value replacement = !needs_patching ? _memory->load(load) : load;
1538,1539c1542,1543
<         StoreField* store = new StoreField(apop(), offset, field, val, false, state_before, is_loaded, true);
<         if (is_loaded) store = _memory->store(store);
---
>         StoreField* store = new StoreField(apop(), offset, field, val, false, state_before, needs_patching);
>         if (!needs_patching) store = _memory->store(store);
2823c2827
<     state->store_local(idx, new Local(objectType, idx));
---
>     state->store_local(idx, new Local(method()->holder(), objectType, idx));
2835c2839
<     state->store_local(idx, new Local(vt, idx));
---
>     state->store_local(idx, new Local(type, vt, idx));
2911a2916,2955
> 
>   case vmIntrinsics::_Reference_get:
>     {
>       if (UseG1GC) {
>         // With java.lang.ref.reference.get() we must go through the
>         // intrinsic - when G1 is enabled - even when get() is the root
>         // method of the compile so that, if necessary, the value in
>         // the referent field of the reference object gets recorded by
>         // the pre-barrier code.
>         // Specifically, if G1 is enabled, the value in the referent
>         // field is recorded by the G1 SATB pre barrier. This will
>         // result in the referent being marked live and the reference
>         // object removed from the list of discovered references during
>         // reference processing.
> 
>         // Set up a stream so that appending instructions works properly.
>         ciBytecodeStream s(scope->method());
>         s.reset_to_bci(0);
>         scope_data()->set_stream(&s);
>         s.next();
> 
>         // setup the initial block state
>         _block = start_block;
>         _state = start_block->state()->copy_for_parsing();
>         _last  = start_block;
>         load_local(objectType, 0);
> 
>         // Emit the intrinsic node.
>         bool result = try_inline_intrinsics(scope->method());
>         if (!result) BAILOUT("failed to inline intrinsic");
>         method_return(apop());
> 
>         // connect the begin and end blocks and we're all done.
>         BlockEnd* end = last()->as_BlockEnd();
>         block()->set_end(end);
>         break;
>       }
>       // Otherwise, fall thru
>     }
> 
3148a3193,3201
>     case vmIntrinsics::_Reference_get:
>       // It is only when G1 is enabled that we absolutely
>       // need to use the intrinsic version of Reference.get()
>       // so that the value in the referent field, if necessary,
>       // can be registered by the pre-barrier code.
>       if (!UseG1GC) return false;
>       preserves_state = true;
>       break;
> 
3304a3358,3365
>   if (compilation()->env()->dtrace_method_probes()) {
>     // Report exit from inline methods.  We don't have a stream here
>     // so pass an explicit bci of SynchronizationEntryBCI.
>     Values* args = new Values(1);
>     args->push(append_with_bci(new Constant(new ObjectConstant(method())), bci));
>     append_with_bci(new RuntimeCall(voidType, "dtrace_method_exit", CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit), args), bci);
>   }
> 
3308c3369
<       lock = append_with_bci(lock, -1);
---
>       lock = append_with_bci(lock, bci);
3312c3373
<     monitorexit(lock, SynchronizationEntryBCI);
---
>     monitorexit(lock, bci);
3488a3550,3554
>   if (compilation()->env()->dtrace_method_probes()) {
>     Values* args = new Values(1);
>     args->push(append(new Constant(new ObjectConstant(method()))));
>     append(new RuntimeCall(voidType, "dtrace_method_entry", CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_entry), args));
>   }
3762,3779c3828
<   const char sync_char      = callee->is_synchronized()        ? 's' : ' ';
<   const char exception_char = callee->has_exception_handlers() ? '!' : ' ';
<   const char monitors_char  = callee->has_monitor_bytecodes()  ? 'm' : ' ';
<   tty->print("     %c%c%c ", sync_char, exception_char, monitors_char);
<   for (int i = 0; i < scope()->level(); i++) tty->print("  ");
<   if (res) {
<     tty->print("  ");
<   } else {
<     tty->print("- ");
<   }
<   tty->print("@ %d  ", bci());
<   callee->print_short_name();
<   tty->print(" (%d bytes)", callee->code_size());
<   if (_inline_bailout_msg) {
<     tty->print("  %s", _inline_bailout_msg);
<   }
<   tty->cr();
< 
---
>   CompileTask::print_inlining(callee, scope()->level(), bci(), _inline_bailout_msg);
diff /home/elise/language/openjdk6/hotspot/src/share/vm/c1/c1_Instruction.cpp /home/elise/language/openjdk/hotspot/src/share/vm/c1/c1_Instruction.cpp
137a138,164
> ciType* Local::exact_type() const {
>   ciType* type = declared_type();
> 
>   // for primitive arrays, the declared type is the exact type
>   if (type->is_type_array_klass()) {
>     return type;
>   } else if (type->is_instance_klass()) {
>     ciInstanceKlass* ik = (ciInstanceKlass*)type;
>     if (ik->is_loaded() && ik->is_final() && !ik->is_interface()) {
>       return type;
>     }
>   } else if (type->is_obj_array_klass()) {
>     ciObjArrayKlass* oak = (ciObjArrayKlass*)type;
>     ciType* base = oak->base_element_type();
>     if (base->is_instance_klass()) {
>       ciInstanceKlass* ik = base->as_instance_klass();
>       if (ik->is_loaded() && ik->is_final()) {
>         return type;
>       }
>     } else if (base->is_primitive_type()) {
>       return type;
>     }
>   }
>   return NULL;
> }
> 
> 
192d218
< 
196a223,225
> ciType* NewArray::declared_type() const {
>   return exact_type();
> }
201a231,233
> ciType* NewInstance::declared_type() const {
>   return exact_type();
> }
351a384,388
> ciType* Invoke::declared_type() const {
>   ciType *t = _target->signature()->return_type();
>   assert(t->basic_type() != T_VOID, "need return value of void method?");
>   return t;
> }
562c599
<   BlockBegin* new_sux = new BlockBegin(-99);
---
>   BlockBegin* new_sux = new BlockBegin(end()->state()->bci());
diff /home/elise/language/openjdk6/hotspot/src/share/vm/c1/c1_Instruction.hpp /home/elise/language/openjdk/hotspot/src/share/vm/c1/c1_Instruction.hpp
108a109
> class   RuntimeCall;
204a206
>   virtual void do_RuntimeCall    (RuntimeCall*     x) = 0;
316a319,320
>   static const int no_bci = -99;
> 
322,323d325
<     IsInitializedFlag,
<     IsLoadedFlag,
621a624
>   ciType*  _declared_type;
624c627
<   Local(ValueType* type, int index)
---
>   Local(ciType* declared, ValueType* type, int index)
626a630
>     , _declared_type(declared)
631a636,638
>   ciType* declared_type() const                  { return _declared_type; }
>   ciType* exact_type() const;
> 
692c699
<               ValueStack* state_before, bool is_loaded, bool is_initialized)
---
>               ValueStack* state_before, bool needs_patching)
700,701d706
<     set_flag(IsLoadedFlag, is_loaded);
<     set_flag(IsInitializedFlag, is_initialized);
702a708
>     set_flag(NeedsPatchingFlag, needs_patching);
704,709d709
<       if (!is_loaded || (PatchALot && !field->is_volatile())) {
<       // need to patch if the holder wasn't loaded or we're testing
<       // using PatchALot.  Don't allow PatchALot for fields which are
<       // known to be volatile they aren't patchable.
<       set_flag(NeedsPatchingFlag, true);
<     }
720,721d719
<   bool is_loaded() const                         { return check_flag(IsLoadedFlag); }
<   bool is_initialized() const                    { return check_flag(IsInitializedFlag); }
724a723,727
>   // Unresolved getstatic and putstatic can cause initialization.
>   // Technically it occurs at the Constant that materializes the base
>   // of the static fields but it's simpler to model it here.
>   bool is_init_point() const                     { return is_static() && (needs_patching() || !_field->holder()->is_initialized()); }
> 
744,745c747,748
<             ValueStack* state_before, bool is_loaded, bool is_initialized)
<   : AccessField(obj, offset, field, is_static, state_before, is_loaded, is_initialized)
---
>             ValueStack* state_before, bool needs_patching)
>   : AccessField(obj, offset, field, is_static, state_before, needs_patching)
752c755
<   HASHING2(LoadField, is_loaded() && !field()->is_volatile(), obj()->subst(), offset())  // cannot be eliminated if not yet loaded or if volatile
---
>   HASHING2(LoadField, !needs_patching() && !field()->is_volatile(), obj()->subst(), offset())  // cannot be eliminated if needs patching or if volatile
763,764c766,767
<              ValueStack* state_before, bool is_loaded, bool is_initialized)
<   : AccessField(obj, offset, field, is_static, state_before, is_loaded, is_initialized)
---
>              ValueStack* state_before, bool needs_patching)
>   : AccessField(obj, offset, field, is_static, state_before, needs_patching)
1150a1154,1155
>   ciType* declared_type() const;
> 
1191a1197
>   ciType* declared_type() const;
1212a1219,1220
>   ciType* declared_type() const;
> 
1401a1410
>   int              _nonnull_state; // mask identifying which args are nonnull
1421a1431
>   , _nonnull_state(AllBits)
1446a1457,1473
>   bool arg_needs_null_check(int i) {
>     if (i >= 0 && i < (int)sizeof(_nonnull_state) * BitsPerByte) {
>       return is_set_nth_bit(_nonnull_state, i);
>     }
>     return true;
>   }
> 
>   void set_arg_needs_null_check(int i, bool check) {
>     if (i >= 0 && i < (int)sizeof(_nonnull_state) * BitsPerByte) {
>       if (check) {
>         _nonnull_state |= nth_bit(i);
>       } else {
>         _nonnull_state &= ~(nth_bit(i));
>       }
>     }
>   }
> 
2269a2297,2328
> 
> // Call some C runtime function that doesn't safepoint,
> // optionally passing the current thread as the first argument.
> LEAF(RuntimeCall, Instruction)
>  private:
>   const char* _entry_name;
>   address     _entry;
>   Values*     _args;
>   bool        _pass_thread;  // Pass the JavaThread* as an implicit first argument
> 
>  public:
>   RuntimeCall(ValueType* type, const char* entry_name, address entry, Values* args, bool pass_thread = true)
>     : Instruction(type)
>     , _entry(entry)
>     , _args(args)
>     , _entry_name(entry_name)
>     , _pass_thread(pass_thread) {
>     ASSERT_VALUES
>     pin();
>   }
> 
>   const char* entry_name() const  { return _entry_name; }
>   address entry() const           { return _entry; }
>   int number_of_arguments() const { return _args->length(); }
>   Value argument_at(int i) const  { return _args->at(i); }
>   bool pass_thread() const        { return _pass_thread; }
> 
>   virtual void input_values_do(ValueVisitor* f)   {
>     for (int i = 0; i < _args->length(); i++) f->visit(_args->adr_at(i));
>   }
> };
> 
diff /home/elise/language/openjdk6/hotspot/src/share/vm/c1/c1_InstructionPrinter.cpp /home/elise/language/openjdk/hotspot/src/share/vm/c1/c1_InstructionPrinter.cpp
135c135
<       output()->print("<unloaded object 0x%x>", value);
---
>       output()->print("<unloaded object " PTR_FORMAT ">", value);
140c140
<       output()->print("<object 0x%x>", value->constant_encoding());
---
>       output()->print("<object " PTR_FORMAT ">", value->constant_encoding());
143c143,148
<     output()->print("<instance 0x%x>", type->as_InstanceConstant()->value()->constant_encoding());
---
>     ciInstance* value = type->as_InstanceConstant()->value();
>     if (value->is_loaded()) {
>       output()->print("<instance " PTR_FORMAT ">", value->constant_encoding());
>     } else {
>       output()->print("<unloaded instance " PTR_FORMAT ">", value);
>     }
145c150
<     output()->print("<array 0x%x>", type->as_ArrayConstant()->value()->constant_encoding());
---
>     output()->print("<array " PTR_FORMAT ">", type->as_ArrayConstant()->value()->constant_encoding());
843a849,857
> void InstructionPrinter::do_RuntimeCall(RuntimeCall* x) {
>   output()->print("call_rt %s(", x->entry_name());
>   for (int i = 0; i < x->number_of_arguments(); i++) {
>     if (i > 0) output()->print(", ");
>     print_value(x->argument_at(i));
>   }
>   output()->put(')');
> }
> 
diff /home/elise/language/openjdk6/hotspot/src/share/vm/c1/c1_InstructionPrinter.hpp /home/elise/language/openjdk/hotspot/src/share/vm/c1/c1_InstructionPrinter.hpp
133a134
>   virtual void do_RuntimeCall    (RuntimeCall*     x);
diff /home/elise/language/openjdk6/hotspot/src/share/vm/c1/c1_LIR.cpp /home/elise/language/openjdk/hotspot/src/share/vm/c1/c1_LIR.cpp
399c399
<     _stub = new ArrayStoreExceptionStub(info_for_exception);
---
>     _stub = new ArrayStoreExceptionStub(object, info_for_exception);
diff /home/elise/language/openjdk6/hotspot/src/share/vm/c1/c1_LIR.hpp /home/elise/language/openjdk/hotspot/src/share/vm/c1/c1_LIR.hpp
1159c1159
<       (method()->holder()->name() == ciSymbol::java_dyn_MethodHandle() &&
---
>       (method()->holder()->name() == ciSymbol::java_lang_invoke_MethodHandle() &&
1218c1218,1222
<     all_flags              = (1 << 8) - 1
---
>     overlapping            = 1 << 8,
>     unaligned              = 1 << 9,
>     src_objarray           = 1 << 10,
>     dst_objarray           = 1 << 11,
>     all_flags              = (1 << 12) - 1
diff /home/elise/language/openjdk6/hotspot/src/share/vm/c1/c1_LIRAssembler.cpp /home/elise/language/openjdk/hotspot/src/share/vm/c1/c1_LIRAssembler.cpp
44a45,52
> #ifdef TARGET_ARCH_arm
> # include "nativeInst_arm.hpp"
> # include "vmreg_arm.inline.hpp"
> #endif
> #ifdef TARGET_ARCH_ppc
> # include "nativeInst_ppc.hpp"
> # include "vmreg_ppc.inline.hpp"
> #endif
830a839,841
>       check_codespace();
>       CHECK_BAILOUT();
> 
diff /home/elise/language/openjdk6/hotspot/src/share/vm/c1/c1_LIRAssembler.hpp /home/elise/language/openjdk/hotspot/src/share/vm/c1/c1_LIRAssembler.hpp
254a255,260
> #ifdef TARGET_ARCH_arm
> # include "c1_LIRAssembler_arm.hpp"
> #endif
> #ifdef TARGET_ARCH_ppc
> # include "c1_LIRAssembler_ppc.hpp"
> #endif
diff /home/elise/language/openjdk6/hotspot/src/share/vm/c1/c1_LIRGenerator.cpp /home/elise/language/openjdk/hotspot/src/share/vm/c1/c1_LIRGenerator.cpp
708a709,740
> static Value maxvalue(IfOp* ifop) {
>   switch (ifop->cond()) {
>     case If::eql: return NULL;
>     case If::neq: return NULL;
>     case If::lss: // x <  y ? x : y
>     case If::leq: // x <= y ? x : y
>       if (ifop->x() == ifop->tval() &&
>           ifop->y() == ifop->fval()) return ifop->y();
>       return NULL;
> 
>     case If::gtr: // x >  y ? y : x
>     case If::geq: // x >= y ? y : x
>       if (ifop->x() == ifop->tval() &&
>           ifop->y() == ifop->fval()) return ifop->y();
>       return NULL;
> 
>   }
> }
> 
> static ciType* phi_declared_type(Phi* phi) {
>   ciType* t = phi->operand_at(0)->declared_type();
>   if (t == NULL) {
>     return NULL;
>   }
>   for(int i = 1; i < phi->operand_count(); i++) {
>     if (t != phi->operand_at(i)->declared_type()) {
>       return NULL;
>     }
>   }
>   return t;
> }
> 
718c750
<   bool is_exact = false;
---
>   bool is_exact = false, src_objarray = false, dst_objarray = false;
721a754,757
>     Phi* phi;
>     if (src_declared_type == NULL && (phi = src->as_Phi()) != NULL) {
>       src_declared_type = as_array_klass(phi_declared_type(phi));
>     }
723a760,763
>     if (dst_declared_type == NULL && (phi = dst->as_Phi()) != NULL) {
>       dst_declared_type = as_array_klass(phi_declared_type(phi));
>     }
> 
746a787,789
> 
>     src_objarray = (src_exact_type && src_exact_type->is_obj_array_klass()) || (src_declared_type && src_declared_type->is_obj_array_klass());
>     dst_objarray = (dst_exact_type && dst_exact_type->is_obj_array_klass()) || (dst_declared_type && dst_declared_type->is_obj_array_klass());
751a795,806
> 
>   if (!src_objarray)
>     flags &= ~LIR_OpArrayCopy::src_objarray;
>   if (!dst_objarray)
>     flags &= ~LIR_OpArrayCopy::dst_objarray;
> 
>   if (!x->arg_needs_null_check(0))
>     flags &= ~LIR_OpArrayCopy::src_null_check;
>   if (!x->arg_needs_null_check(2))
>     flags &= ~LIR_OpArrayCopy::dst_null_check;
> 
> 
753,754c808,823
<     // try to skip null checks
<     if (src->as_NewArray() != NULL)
---
>     Value length_limit = NULL;
> 
>     IfOp* ifop = length->as_IfOp();
>     if (ifop != NULL) {
>       // look for expressions like min(v, a.length) which ends up as
>       //   x > y ? y : x  or  x >= y ? y : x
>       if ((ifop->cond() == If::gtr || ifop->cond() == If::geq) &&
>           ifop->x() == ifop->fval() &&
>           ifop->y() == ifop->tval()) {
>         length_limit = ifop->y();
>       }
>     }
> 
>     // try to skip null checks and range checks
>     NewArray* src_array = src->as_NewArray();
>     if (src_array != NULL) {
756c825,833
<     if (dst->as_NewArray() != NULL)
---
>       if (length_limit != NULL &&
>           src_array->length() == length_limit &&
>           is_constant_zero(src_pos)) {
>         flags &= ~LIR_OpArrayCopy::src_range_check;
>       }
>     }
> 
>     NewArray* dst_array = dst->as_NewArray();
>     if (dst_array != NULL) {
757a835,840
>       if (length_limit != NULL &&
>           dst_array->length() == length_limit &&
>           is_constant_zero(dst_pos)) {
>         flags &= ~LIR_OpArrayCopy::dst_range_check;
>       }
>     }
790a874,895
>   IntConstant* src_int = src_pos->type()->as_IntConstant();
>   IntConstant* dst_int = dst_pos->type()->as_IntConstant();
>   if (src_int && dst_int) {
>     int s_offs = src_int->value();
>     int d_offs = dst_int->value();
>     if (src_int->value() >= dst_int->value()) {
>       flags &= ~LIR_OpArrayCopy::overlapping;
>     }
>     if (expected_type != NULL) {
>       BasicType t = expected_type->element_type()->basic_type();
>       int element_size = type2aelembytes(t);
>       if (((arrayOopDesc::base_offset_in_bytes(t) + s_offs * element_size) % HeapWordSize == 0) &&
>           ((arrayOopDesc::base_offset_in_bytes(t) + d_offs * element_size) % HeapWordSize == 0)) {
>         flags &= ~LIR_OpArrayCopy::unaligned;
>       }
>     }
>   } else if (src_pos == dst_pos || is_constant_zero(dst_pos)) {
>     // src and dest positions are the same, or dst is zero so assume
>     // nonoverlapping copy.
>     flags &= ~LIR_OpArrayCopy::overlapping;
>   }
> 
1106a1212,1243
> // Examble: ref.get()
> // Combination of LoadField and g1 pre-write barrier
> void LIRGenerator::do_Reference_get(Intrinsic* x) {
> 
>   const int referent_offset = java_lang_ref_Reference::referent_offset;
>   guarantee(referent_offset > 0, "referent offset not initialized");
> 
>   assert(x->number_of_arguments() == 1, "wrong type");
> 
>   LIRItem reference(x->argument_at(0), this);
>   reference.load_item();
> 
>   // need to perform the null check on the reference objecy
>   CodeEmitInfo* info = NULL;
>   if (x->needs_null_check()) {
>     info = state_for(x);
>   }
> 
>   LIR_Address* referent_field_adr =
>     new LIR_Address(reference.result(), referent_offset, T_OBJECT);
> 
>   LIR_Opr result = rlock_result(x);
> 
>   __ load(referent_field_adr, result, info);
> 
>   // Register the value in the referent field with the pre-barrier
>   pre_barrier(LIR_OprFact::illegalOpr /* addr_opr */,
>               result /* pre_val */,
>               false  /* do_load */,
>               false  /* patch */,
>               NULL   /* info */);
> }
1249c1386,1387
< void LIRGenerator::pre_barrier(LIR_Opr addr_opr, bool patch,  CodeEmitInfo* info) {
---
> void LIRGenerator::pre_barrier(LIR_Opr addr_opr, LIR_Opr pre_val,
>                                bool do_load, bool patch, CodeEmitInfo* info) {
1255c1393
<       G1SATBCardTableModRef_pre_barrier(addr_opr, patch, info);
---
>       G1SATBCardTableModRef_pre_barrier(addr_opr, pre_val, do_load, patch, info);
1296,1298c1434,1435
< void LIRGenerator::G1SATBCardTableModRef_pre_barrier(LIR_Opr addr_opr, bool patch,  CodeEmitInfo* info) {
<   if (G1DisablePreBarrier) return;
< 
---
> void LIRGenerator::G1SATBCardTableModRef_pre_barrier(LIR_Opr addr_opr, LIR_Opr pre_val,
>                                                      bool do_load, bool patch, CodeEmitInfo* info) {
1316a1454
>   __ cmp(lir_cond_notEqual, flag_val, LIR_OprFact::intConst(0));
1318,1319c1456
<   LIR_PatchCode pre_val_patch_code =
<     patch ? lir_patch_normal : lir_patch_none;
---
>   LIR_PatchCode pre_val_patch_code = lir_patch_none;
1321c1458
<   LIR_Opr pre_val = new_register(T_OBJECT);
---
>   CodeStub* slow;
1323,1326c1460,1480
<   __ cmp(lir_cond_notEqual, flag_val, LIR_OprFact::intConst(0));
<   if (!addr_opr->is_address()) {
<     assert(addr_opr->is_register(), "must be");
<     addr_opr = LIR_OprFact::address(new LIR_Address(addr_opr, T_OBJECT));
---
>   if (do_load) {
>     assert(pre_val == LIR_OprFact::illegalOpr, "sanity");
>     assert(addr_opr != LIR_OprFact::illegalOpr, "sanity");
> 
>     if (patch)
>       pre_val_patch_code = lir_patch_normal;
> 
>     pre_val = new_register(T_OBJECT);
> 
>     if (!addr_opr->is_address()) {
>       assert(addr_opr->is_register(), "must be");
>       addr_opr = LIR_OprFact::address(new LIR_Address(addr_opr, T_OBJECT));
>     }
>     slow = new G1PreBarrierStub(addr_opr, pre_val, pre_val_patch_code, info);
>   } else {
>     assert(addr_opr == LIR_OprFact::illegalOpr, "sanity");
>     assert(pre_val->is_register(), "must be");
>     assert(pre_val->type() == T_OBJECT, "must be an object");
>     assert(info == NULL, "sanity");
> 
>     slow = new G1PreBarrierStub(pre_val);
1328,1329c1482
<   CodeStub* slow = new G1PreBarrierStub(addr_opr, pre_val, pre_val_patch_code,
<                                         info);
---
> 
1335,1336d1487
<   if (G1DisablePostBarrier) return;
< 
1354c1505
<     LIR_Opr ptr = new_register(T_OBJECT);
---
>     LIR_Opr ptr = new_pointer_register();
1406c1557,1559
<     LIR_Opr ptr = new_register(T_OBJECT);
---
>     // ptr cannot be an object because we use this barrier for array card marks
>     // and addr can point in the middle of an array.
>     LIR_Opr ptr = new_pointer_register();
1557a1711,1712
>                 LIR_OprFact::illegalOpr /* pre_val */,
>                 true /* do_load*/,
1562,1564c1717
<   if (is_volatile) {
<     assert(!needs_patching && x->is_loaded(),
<            "how do we know it's volatile if it's not loaded");
---
>   if (is_volatile && !needs_patching) {
1630,1632c1783
<   if (is_volatile) {
<     assert(!needs_patching && x->is_loaded(),
<            "how do we know it's volatile if it's not loaded");
---
>   if (is_volatile && !needs_patching) {
1991c2142
<   LIR_Opr reg = reg = rlock_result(x, x->basic_type());
---
>   LIR_Opr reg = rlock_result(x, x->basic_type());
1993a2145,2279
> 
> #ifndef SERIALGC
>   // We might be reading the value of the referent field of a
>   // Reference object in order to attach it back to the live
>   // object graph. If G1 is enabled then we need to record
>   // the value that is being returned in an SATB log buffer.
>   //
>   // We need to generate code similar to the following...
>   //
>   // if (offset == java_lang_ref_Reference::referent_offset) {
>   //   if (src != NULL) {
>   //     if (klass(src)->reference_type() != REF_NONE) {
>   //       pre_barrier(..., reg, ...);
>   //     }
>   //   }
>   // }
>   //
>   // The first non-constant check of either the offset or
>   // the src operand will be done here; the remainder
>   // will take place in the generated code stub.
> 
>   if (UseG1GC && type == T_OBJECT) {
>     bool gen_code_stub = true;       // Assume we need to generate the slow code stub.
>     bool gen_offset_check = true;       // Assume the code stub has to generate the offset guard.
>     bool gen_source_check = true;       // Assume the code stub has to check the src object for null.
> 
>     if (off.is_constant()) {
>       jlong off_con = (off.type()->is_int() ?
>                         (jlong) off.get_jint_constant() :
>                         off.get_jlong_constant());
> 
> 
>       if (off_con != (jlong) java_lang_ref_Reference::referent_offset) {
>         // The constant offset is something other than referent_offset.
>         // We can skip generating/checking the remaining guards and
>         // skip generation of the code stub.
>         gen_code_stub = false;
>       } else {
>         // The constant offset is the same as referent_offset -
>         // we do not need to generate a runtime offset check.
>         gen_offset_check = false;
>       }
>     }
> 
>     // We don't need to generate stub if the source object is an array
>     if (gen_code_stub && src.type()->is_array()) {
>       gen_code_stub = false;
>     }
> 
>     if (gen_code_stub) {
>       // We still need to continue with the checks.
>       if (src.is_constant()) {
>         ciObject* src_con = src.get_jobject_constant();
> 
>         if (src_con->is_null_object()) {
>           // The constant src object is null - We can skip
>           // generating the code stub.
>           gen_code_stub = false;
>         } else {
>           // Non-null constant source object. We still have to generate
>           // the slow stub - but we don't need to generate the runtime
>           // null object check.
>           gen_source_check = false;
>         }
>       }
>     }
> 
>     if (gen_code_stub) {
>       // Temoraries.
>       LIR_Opr src_klass = new_register(T_OBJECT);
> 
>       // Get the thread pointer for the pre-barrier
>       LIR_Opr thread = getThreadPointer();
> 
>       CodeStub* stub;
> 
>       // We can have generate one runtime check here. Let's start with
>       // the offset check.
>       if (gen_offset_check) {
>         // if (offset == referent_offset) -> slow code stub
>         // If offset is an int then we can do the comparison with the
>         // referent_offset constant; otherwise we need to move
>         // referent_offset into a temporary register and generate
>         // a reg-reg compare.
> 
>         LIR_Opr referent_off;
> 
>         if (off.type()->is_int()) {
>           referent_off = LIR_OprFact::intConst(java_lang_ref_Reference::referent_offset);
>         } else {
>           assert(off.type()->is_long(), "what else?");
>           referent_off = new_register(T_LONG);
>           __ move(LIR_OprFact::longConst(java_lang_ref_Reference::referent_offset), referent_off);
>         }
> 
>         __ cmp(lir_cond_equal, off.result(), referent_off);
> 
>         // Optionally generate "src == null" check.
>         stub = new G1UnsafeGetObjSATBBarrierStub(reg, src.result(),
>                                                     src_klass, thread,
>                                                     gen_source_check);
> 
>         __ branch(lir_cond_equal, as_BasicType(off.type()), stub);
>       } else {
>         if (gen_source_check) {
>           // offset is a const and equals referent offset
>           // if (source != null) -> slow code stub
>           __ cmp(lir_cond_notEqual, src.result(), LIR_OprFact::oopConst(NULL));
> 
>           // Since we are generating the "if src == null" guard here,
>           // there is no need to generate the "src == null" check again.
>           stub = new G1UnsafeGetObjSATBBarrierStub(reg, src.result(),
>                                                     src_klass, thread,
>                                                     false);
> 
>           __ branch(lir_cond_notEqual, T_OBJECT, stub);
>         } else {
>           // We have statically determined that offset == referent_offset
>           // && src != null so we unconditionally branch to code stub
>           // to perform the guards and record reg in the SATB log buffer.
> 
>           stub = new G1UnsafeGetObjSATBBarrierStub(reg, src.result(),
>                                                     src_klass, thread,
>                                                     false);
> 
>           __ branch(lir_cond_always, T_ILLEGAL, stub);
>         }
>       }
> 
>       // Continuation point
>       __ branch_destination(stub->continuation());
>     }
>   }
> #endif // SERIALGC
> 
2516c2802
<       __ load(new LIR_Address(tmp, call_site_offset, T_OBJECT), tmp);
---
>       __ move_wide(new LIR_Address(tmp, call_site_offset, T_OBJECT), tmp);
2519c2805
<       __ load(new LIR_Address(tmp, java_dyn_CallSite::target_offset_in_bytes(), T_OBJECT), receiver);
---
>       __ load(new LIR_Address(tmp, java_lang_invoke_CallSite::target_offset_in_bytes(), T_OBJECT), receiver);
2658a2945,2948
>   case vmIntrinsics::_Reference_get:
>     do_Reference_get(x);
>     break;
> 
2743a3034,3058
> void LIRGenerator::do_RuntimeCall(RuntimeCall* x) {
>   LIR_OprList* args = new LIR_OprList(x->number_of_arguments());
>   BasicTypeList* signature = new BasicTypeList(x->number_of_arguments());
> 
>   if (x->pass_thread()) {
>     signature->append(T_ADDRESS);
>     args->append(getThreadPointer());
>   }
> 
>   for (int i = 0; i < x->number_of_arguments(); i++) {
>     Value a = x->argument_at(i);
>     LIRItem* item = new LIRItem(a, this);
>     item->load_item();
>     args->append(item->result());
>     signature->append(as_BasicType(a->type()));
>   }
> 
>   LIR_Opr result = call_runtime(signature, args, x->entry(), x->type(), NULL);
>   if (x->type() == voidType) {
>     set_no_result(x);
>   } else {
>     __ move(result, rlock_result(x));
>   }
> }
> 
diff /home/elise/language/openjdk6/hotspot/src/share/vm/c1/c1_LIRGenerator.hpp /home/elise/language/openjdk/hotspot/src/share/vm/c1/c1_LIRGenerator.hpp
248a249
>   void do_Reference_get(Intrinsic* x);
263c264
<   void pre_barrier(LIR_Opr addr_opr, bool patch,  CodeEmitInfo* info);
---
>   void pre_barrier(LIR_Opr addr_opr, LIR_Opr pre_val, bool do_load, bool patch, CodeEmitInfo* info);
269c270,271
<   void G1SATBCardTableModRef_pre_barrier(LIR_Opr addr_opr, bool patch,  CodeEmitInfo* info);
---
>   void G1SATBCardTableModRef_pre_barrier(LIR_Opr addr_opr, LIR_Opr pre_val,
>                                          bool do_load, bool patch, CodeEmitInfo* info);
524a527
>   virtual void do_RuntimeCall    (RuntimeCall*     x);
diff /home/elise/language/openjdk6/hotspot/src/share/vm/c1/c1_LinearScan.cpp /home/elise/language/openjdk/hotspot/src/share/vm/c1/c1_LinearScan.cpp
43a44,49
> #ifdef TARGET_ARCH_arm
> # include "vmreg_arm.inline.hpp"
> #endif
> #ifdef TARGET_ARCH_ppc
> # include "vmreg_ppc.inline.hpp"
> #endif
2700c2706
<       assert(opr->fpu_regnrLo() == opr->fpu_regnrHi(), "assumed in calculation (only fpu_regnrHi is used)");
---
>       assert(opr->fpu_regnrLo() == opr->fpu_regnrHi(), "assumed in calculation (only fpu_regnrLo is used)");
2711a2718,2720
> #ifdef VM_LITTLE_ENDIAN
>       VMReg rname_first = frame_map()->fpu_regname(opr->fpu_regnrLo());
> #else
2712a2722,2723
> #endif
> 
diff /home/elise/language/openjdk6/hotspot/src/share/vm/c1/c1_LinearScan.hpp /home/elise/language/openjdk/hotspot/src/share/vm/c1/c1_LinearScan.hpp
974a975,980
> #ifdef TARGET_ARCH_arm
> # include "c1_LinearScan_arm.hpp"
> #endif
> #ifdef TARGET_ARCH_ppc
> # include "c1_LinearScan_ppc.hpp"
> #endif
diff /home/elise/language/openjdk6/hotspot/src/share/vm/c1/c1_MacroAssembler.hpp /home/elise/language/openjdk/hotspot/src/share/vm/c1/c1_MacroAssembler.hpp
37a38,43
> #ifdef TARGET_ARCH_arm
> # include "assembler_arm.inline.hpp"
> #endif
> #ifdef TARGET_ARCH_ppc
> # include "assembler_ppc.inline.hpp"
> #endif
63a70,75
> #ifdef TARGET_ARCH_arm
> # include "c1_MacroAssembler_arm.hpp"
> #endif
> #ifdef TARGET_ARCH_ppc
> # include "c1_MacroAssembler_ppc.hpp"
> #endif
diff /home/elise/language/openjdk6/hotspot/src/share/vm/c1/c1_Optimizer.cpp /home/elise/language/openjdk/hotspot/src/share/vm/c1/c1_Optimizer.cpp
255,264c255,265
<         guarantee(t_compare_res != Constant::not_comparable && f_compare_res != Constant::not_comparable, "incomparable constants in IfOp");
< 
<         Value new_tval = t_compare_res == Constant::cond_true ? tval : fval;
<         Value new_fval = f_compare_res == Constant::cond_true ? tval : fval;
< 
<         _ifop_count++;
<         if (new_tval == new_fval) {
<           return new_tval;
<         } else {
<           return new IfOp(x_ifop->x(), x_ifop_cond, x_ifop->y(), new_tval, new_fval);
---
>         // not_comparable here is a valid return in case we're comparing unloaded oop constants
>         if (t_compare_res != Constant::not_comparable && f_compare_res != Constant::not_comparable) {
>           Value new_tval = t_compare_res == Constant::cond_true ? tval : fval;
>           Value new_fval = f_compare_res == Constant::cond_true ? tval : fval;
> 
>           _ifop_count++;
>           if (new_tval == new_fval) {
>             return new_tval;
>           } else {
>             return new IfOp(x_ifop->x(), x_ifop_cond, x_ifop->y(), new_tval, new_fval);
>           }
271,274c272,276
<         guarantee(x_compare_res != Constant::not_comparable, "incomparable constants in IfOp");
< 
<         _ifop_count++;
<         return x_compare_res == Constant::cond_true ? tval : fval;
---
>         // not_comparable here is a valid return in case we're comparing unloaded oop constants
>         if (x_compare_res != Constant::not_comparable) {
>           _ifop_count++;
>           return x_compare_res == Constant::cond_true ? tval : fval;
>         }
498a501
>   void do_RuntimeCall    (RuntimeCall*     x);
646c649
< void NullCheckVisitor::do_Intrinsic      (Intrinsic*       x) { nce()->clear_last_explicit_null_check(); }
---
> void NullCheckVisitor::do_Intrinsic      (Intrinsic*       x) { nce()->handle_Intrinsic(x);     }
666a670
> void NullCheckVisitor::do_RuntimeCall    (RuntimeCall*     x) {}
1023a1028,1033
>     if (x->id() == vmIntrinsics::_arraycopy) {
>       for (int i = 0; i < x->number_of_arguments(); i++) {
>         x->set_arg_needs_null_check(i, !set_contains(x->argument_at(i)));
>       }
>     }
> 
diff /home/elise/language/openjdk6/hotspot/src/share/vm/c1/c1_Runtime1.cpp /home/elise/language/openjdk/hotspot/src/share/vm/c1/c1_Runtime1.cpp
105a106
> int Runtime1::_generic_arraycopystub_cnt = 0;
106a108,109
> int Runtime1::_arraycopy_checkcast_cnt = 0;
> int Runtime1::_arraycopy_checkcast_attempt_cnt = 0;
121a125,150
> 
> static int _byte_arraycopy_cnt = 0;
> static int _short_arraycopy_cnt = 0;
> static int _int_arraycopy_cnt = 0;
> static int _long_arraycopy_cnt = 0;
> static int _oop_arraycopy_cnt = 0;
> 
> address Runtime1::arraycopy_count_address(BasicType type) {
>   switch (type) {
>   case T_BOOLEAN:
>   case T_BYTE:   return (address)&_byte_arraycopy_cnt;
>   case T_CHAR:
>   case T_SHORT:  return (address)&_short_arraycopy_cnt;
>   case T_FLOAT:
>   case T_INT:    return (address)&_int_arraycopy_cnt;
>   case T_DOUBLE:
>   case T_LONG:   return (address)&_long_arraycopy_cnt;
>   case T_ARRAY:
>   case T_OBJECT: return (address)&_oop_arraycopy_cnt;
>   default:
>     ShouldNotReachHere();
>     return NULL;
>   }
> }
> 
> 
342,343c371,374
< JRT_ENTRY(void, Runtime1::throw_array_store_exception(JavaThread* thread))
<   THROW(vmSymbolHandles::java_lang_ArrayStoreException());
---
> JRT_ENTRY(void, Runtime1::throw_array_store_exception(JavaThread* thread, oopDesc* obj))
>   ResourceMark rm(thread);
>   const char* klass_name = Klass::cast(obj->klass())->external_name();
>   SharedRuntime::throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_ArrayStoreException(), klass_name);
427,429d457
< //
< 
< 
430a459,460
>   // Reset method handle flag.
>   thread->set_is_method_handle_return(false);
481c511
<   // ExceptionCache is used only for exceptions at call and not for implicit exceptions
---
>   // ExceptionCache is used only for exceptions at call sites and not for implicit exceptions
485c515,516
<       if (fast_continuation == ExceptionCache::unwind_handler()) fast_continuation = NULL;
---
>       // Set flag if return address is a method handle call site.
>       thread->set_is_method_handle_return(nm->is_method_handle_return(pc));
523,525c554
<     if (continuation == NULL) {
<       nm->add_handler_for_exception_and_pc(exception, pc, ExceptionCache::unwind_handler());
<     } else {
---
>     if (continuation != NULL) {
530a560,561
>   // Set flag if return address is a method handle call site.
>   thread->set_is_method_handle_return(nm->is_method_handle_return(pc));
543c574
< // in the method handling the exception
---
> // in the method handling the exception.
547c578
< address  Runtime1::exception_handler_for_pc(JavaThread* thread) {
---
> address Runtime1::exception_handler_for_pc(JavaThread* thread) {
551c582
<   debug_only(ResetNoHandleMark rnhm);
---
>   DEBUG_ONLY(ResetNoHandleMark rnhm);
556d586
< 
564d593
< 
568a598
>   assert(continuation != NULL, "no handler found");
810c840
<           k = klass;
---
>           k = klass->java_mirror();
998a1029,1040
>             nmethod* nm = CodeCache::find_nmethod(instr_pc);
>             oop* oop_addr = NULL;
>             assert(nm != NULL, "invalid nmethod_pc");
>             RelocIterator oops(nm, copy_buff, copy_buff + 1);
>             while (oops.next()) {
>               if (oops.type() == relocInfo::oop_type) {
>                 oop_Relocation* r = oops.oop_reloc();
>                 oop_addr = r->oop_addr();
>                 break;
>               }
>             }
>             assert(oop_addr != NULL, "oop relocation must exist");
1001c1043
<             n_copy2->set_data((intx) (load_klass()), instr_pc);
---
>             n_copy2->set_pc_relative_offset((address)oop_addr, instr_pc);
1230a1273,1277
>   tty->print_cr(" _generic_arraycopystub_cnt:      %d", _generic_arraycopystub_cnt);
>   tty->print_cr(" _byte_arraycopy_cnt:             %d", _byte_arraycopy_cnt);
>   tty->print_cr(" _short_arraycopy_cnt:            %d", _short_arraycopy_cnt);
>   tty->print_cr(" _int_arraycopy_cnt:              %d", _int_arraycopy_cnt);
>   tty->print_cr(" _long_arraycopy_cnt:             %d", _long_arraycopy_cnt);
1232c1279,1280
<   tty->print_cr(" _oop_arraycopy_cnt:              %d", _oop_arraycopy_cnt);
---
>   tty->print_cr(" _oop_arraycopy_cnt (C):          %d", Runtime1::_oop_arraycopy_cnt);
>   tty->print_cr(" _oop_arraycopy_cnt (stub):       %d", _oop_arraycopy_cnt);
1233a1282,1283
>   tty->print_cr(" _arraycopy_checkcast_cnt:        %d", _arraycopy_checkcast_cnt);
>   tty->print_cr(" _arraycopy_checkcast_attempt_cnt:%d", _arraycopy_checkcast_attempt_cnt);
diff /home/elise/language/openjdk6/hotspot/src/share/vm/c1/c1_Runtime1.hpp /home/elise/language/openjdk/hotspot/src/share/vm/c1/c1_Runtime1.hpp
56a57
>   stub(handle_exception_from_callee) \
95a97
>   static int _generic_arraycopystub_cnt;
96a99,100
>   static int _arraycopy_checkcast_cnt;
>   static int _arraycopy_checkcast_attempt_cnt;
119,120c123,124
<   static void generate_blob_for(BufferBlob* blob, StubID id);
<   static OopMapSet* generate_code_for(StubID id, StubAssembler* masm);
---
>   static void       generate_blob_for(BufferBlob* blob, StubID id);
>   static OopMapSet* generate_code_for(StubID id, StubAssembler* sasm);
122,123c126,127
<   static void generate_handle_exception(StubAssembler *sasm, OopMapSet* oop_maps, OopMap* oop_map, bool ignore_fpu_registers = false);
<   static void generate_unwind_exception(StubAssembler *sasm);
---
>   static OopMapSet* generate_handle_exception(StubID id, StubAssembler* sasm);
>   static void       generate_unwind_exception(StubAssembler *sasm);
146c150
<   static void throw_class_cast_exception(JavaThread* thread, oopDesc* obect);
---
>   static void throw_class_cast_exception(JavaThread* thread, oopDesc* object);
148c152
<   static void throw_array_store_exception(JavaThread* thread);
---
>   static void throw_array_store_exception(JavaThread* thread, oopDesc* object);
176c180,181
<   static address throw_count_address()       { return (address)&_throw_count;       }
---
>   static address throw_count_address()               { return (address)&_throw_count;             }
>   static address arraycopy_count_address(BasicType type);
diff /home/elise/language/openjdk6/hotspot/src/share/vm/c1/c1_ValueMap.hpp /home/elise/language/openjdk/hotspot/src/share/vm/c1/c1_ValueMap.hpp
144c144,145
<     if (!x->is_initialized()) {
---
>     if (x->is_init_point()) {
>       // putstatic is an initialization point so treat it as a wide kill
162c163,164
<     if (!x->is_initialized()) {
---
>     if (x->is_init_point()) {
>       // getstatic is an initialization point so treat it as a wide kill
195d196
<   void do_ProfileInvoke  (ProfileInvoke*   x) { /* nothing to do */ };
199a201,202
>   void do_ProfileInvoke  (ProfileInvoke*   x) { /* nothing to do */ };
>   void do_RuntimeCall    (RuntimeCall*     x) { /* nothing to do */ };
diff /home/elise/language/openjdk6/hotspot/src/share/vm/c1/c1_globals.hpp /home/elise/language/openjdk/hotspot/src/share/vm/c1/c1_globals.hpp
34a35,40
> #ifdef TARGET_ARCH_arm
> # include "c1_globals_arm.hpp"
> #endif
> #ifdef TARGET_ARCH_ppc
> # include "c1_globals_ppc.hpp"
> #endif
